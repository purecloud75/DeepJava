import java.util.ArrayList;
import java.util.LinkedList;

public class Introduce {
    public static void main(String[] args) {


    }
}
/*
int[] arr1 = new int[4];
int[] arr2 = new int[]{10, 20, 30, 40};
String[] arr3 = {"Jung", "Nam"};
과 같은 배열과, 리스트가 존재한다. 위와 같이 배열은 3가지 방식으로 선언이 된다!
배열은 arr2[2] = 100;이라 했을 때,기존의 30를 100으로 덮어씌우기 때문에 여전히 배열의 크기는 4이다.
각 데이터에 대한 인덱스는 여전히 그대로이다. 무슨말이냐면 arr2[3]은 여전히 40인 것이다. 주민번호 같음. 배열의 크기가 정해져있어서 융통성없음

하지만
ArrayList arr22 = new ArrayList<>();
LinkedList arr11 = new LinkedList<>();
과 같은 리스트는 다르다. 중간에 삽입을 하거나 삭제를 하면 한 칸씩 밀려나거나 채워야하기에 빈틈없이 연결성이 유지되는 장점이 있다.
이렇게 자바는 배열리스트와 연결리스트(단일과 이중 모두지원), 2개의 리스트를 지원한다.

배열리스트는 데이터가 저장되어있는 인덱스를 안다면 빠르게 조회가 가능. 내부적으로 배열을 쓰기에 배열크기가 고정되어있어서 한계가 있음.
원칙은 이렇지만 실제로는 배열의 크키를 넘어서는 객체를 이어붙이면, 원래크기의 2배의 배열을 새로만들어서 기존배열의 데이터를 새 배열에 복사하고
기존배열은 삭제된다. 또 넘어서면 또 2배크기의 배열을 만들고... 이를 반복하기에 사실 배열리스트도 연결리스트처럼 크기(길이)에 있어 유동적이다.

연결리스트는 데이터를 빠르게 추가 및 삭제가 가능. 참조값으로 각각의 노드가 연결되있음. 리스트의 크기를 메모리가 되는 한 무한히 연장 가능.
어느누구도 나를 가르켜주지않아 나를 바라보고있지않다면 그건 그들로부터 잊혀진거다 즉, 삭제된거다

이중연결리스트는 다음노드와 이전노드에 대한 링크영역이 각각 1개씩, 총 2개가 있어서 양방향의 성격을 띤다.
찾고자하는 노드가 제일끝에있다고하면, 처음부터 다 찾는것이아니라 마지막서부터 이전노드쪽으로 탐색할수도있다. 전체 노드 수의 절반을 구해서
그 절반보다 찾고자하는 노드의 인덱스가 적다면 앞에서부터, 크다면 뒤에서부터 찾으면 2배는 더 효율적이다. 하지만 메모리를 더 차지한다. 이전링크.

사용자는 그때그때 더 효율적인 자료구조를 직접 택해야 한다. head와 tail과 pointer와 next등등의 변수는 다 노드를 가리키는 바깥변수일 뿐이다.
CPU는 STORAGE에 저장되어있는 여러 파일들을 처리하는 데, 직접 가져다쓰면 너무오래걸려서 STORAGE -> MEMORY -> CPU 순서로 데이터를 받는다
STORAGE에는 HDD/SDD, MEMORY에는 DRAM 이 있다.
자료구조의 목표는 메모리의 효율적 사용이다.
*/



