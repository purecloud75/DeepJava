import java.util.ArrayList;
import java.util.LinkedList;

public class Introduce {
    public static void main(String[] args) {


    }
}
/*
int[] arr1 = new int[4];
int[] arr2 = new int[]{10, 20, 30, 40};
String[] arr3 = {"Jung", "Nam"};
과 같은 배열과, 리스트가 존재한다. 위와 같이 배열은 3가지 방식으로 선언이 된다!
배열은 arr2[2] = 100;이라 했을 때,기존의 30를 100으로 덮어씌우기 때문에 여전히 배열의 크기는 4이다.
각 데이터에 대한 인덱스는 여전히 그대로이다. 무슨말이냐면 arr2[3]은 여전히 40인 것이다. 주민번호 같음. 배열의 크기가 정해져있어서 융통성없음

하지만
ArrayList arr22 = new ArrayList<>();
LinkedList arr11 = new LinkedList<>();
과 같은 리스트는 다르다. 중간에 삽입을 하거나 삭제를 하면 한 칸씩 밀려나거나 채워야하기에 빈틈없이 연결성이 유지되는 장점이 있다.
이렇게 자바는 배열리스트와 연결리스트(단일과 이중 모두지원), 2개의 리스트를 지원한다.

배열리스트는 데이터가 저장되어있는 인덱스를 안다면 빠르게 조회가 가능. 내부적으로 배열을 쓰기에 배열크기가 고정되어있어서 한계가 있음.
원칙은 이렇지만 실제로는 배열의 크키를 넘어서는 객체를 이어붙이면, 원래크기의 2배의 배열을 새로만들어서 기존배열의 데이터를 새 배열에 복사하고
기존배열은 삭제된다. 또 넘어서면 또 2배크기의 배열을 만들고... 이를 반복하기에 사실 배열리스트도 연결리스트처럼 크기(길이)에 있어 유동적이다.

연결리스트는 데이터를 빠르게 추가 및 삭제가 가능. 참조값으로 각각의 노드가 연결되있음. 리스트의 크기를 메모리가 되는 한 무한히 연장 가능.
어느누구도 나를 가르켜주지않아 나를 바라보고있지않다면 그건 그들로부터 잊혀진거다 즉, 삭제된거다. 
다만 어떤 노드를 추가, 삭제하기 위해선 그 노드의 이전노드를 찾아야 하는데, 그걸 처음서부터 하나씩 오기때문에 오래걸린다.

이중연결리스트는 다음노드와 이전노드에 대한 링크영역이 각각 1개씩, 총 2개가 있어서 양방향의 성격을 띤다.
찾고자하는 노드가 제일끝에있다고하면, 처음부터 다 찾는것이아니라 마지막서부터 이전노드쪽으로 탐색할수도있다. 전체 노드 수의 절반을 구해서
그 절반보다 찾고자하는 노드의 인덱스가 적다면 앞에서부터, 크다면 뒤에서부터 찾으면 2배는 더 효율적이다. 하지만 메모리를 더 차지한다. 이전링크.

사용자는 그때그때 더 효율적인 자료구조를 직접 택해야 한다. head와 tail과 pointer와 next등등의 변수는 다 노드를 가리키는 바깥변수일 뿐이다.
CPU는 STORAGE에 저장되어있는 여러 파일들을 처리하는 데, 직접 가져다쓰면 너무오래걸려서 STORAGE -> MEMORY -> CPU 순서로 데이터를 받는다
STORAGE에는 HDD/SDD, MEMORY에는 DRAM 이 있다.
자료구조의 목표는 메모리의 효율적 사용이다.

스택은 last in, first out(쌓여진 접시를 꺼낼때)
큐는 first in, first out(선착순 또는 극장 줄서기)

트리 중에서 이진트리(부모노드에 자식노드가 두 개 이하인 트리)를 활용해서 힙과 이진탐색트리를 구현한다.
힙은 맥스힙 또는 민힙으로 우선순위 큐를 구현하고, 힙정렬에 쓰인다.
이진탐색트리는 자료(key)의 중복을 허용하지 않고, 왼쪽은 부모노드보다 작은값을 오른쪽은 큰 값을 저장한다. 자료검색에 걸리는 평균시간은 로그이다.

그래프는 정점(노드)과 간선(링크)들의 유한집합이다.
그래프의 구현방법은 인접행렬, 인접리스트가 있다. 그래프의 탐색방법은 너비우선탐색, 깊이우선탐색이 있다.

해싱은 자료를 검색하기 위한 자료구조이다. key 에 대한 자료룰 검색하기 위한 사전(dictionary)개념의 자료구조이다.
key 는 유일하고 이에 대한 value 를 쌍으로 저장한다. 검색에 들어가는 속도가 O(1)이다.
index = h(key) : 해시 함수가 key 에 대한 인덱스를 반환해주고 해당 인덱스위치에 자료를 저장하거나 검색하게 됨.
저장되는 메모리구조를 해시테이블이라고 한다. 연결리스트를 활용한 체이닝 기법을 많이 쓴다.
123 % 100 = 23, 223 % 100 = 23 -> key 는 다르지만 해시함수의 반환값(해당 인덱스)가 같으면 충돌 발생. 이를 해결하기위한 알고리즘들이 있다
*/



