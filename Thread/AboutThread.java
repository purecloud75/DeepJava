public class AboutThread {
}

/*
운영체제에서 실행중인 하나의 애플리케이션은 프로세스라고 한다. 사용자가 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아
애플리케이션의 코드를 실행하는데 이것이 프로세스이다. 하나의 어플이 멀티프로세스를 만들기도 하는데 크롬브라우저를 두 개 실행한 경우가 해당.

멀티태스킹은 두가지 이상의 작업을 동시에 처리하는 것을 말하는데, 운영체제는 멀티태스킹을 할 수 있도록 CPU 및 메모리 자원을 프로세스마다
적절히 할당해주고 병렬로 실행시킨다. 워드로 문서작업하면서 동시에 미디어플레이어로 음악을 듣는 경우가 해당.
워드와 미디어플레이어는 독립된 각각의 메모리를 갖는 프로세스들(멀티프로세스)이다.

하나의 프로세스 내에서 멀티태스킹을 할 수 있는 경우도 있는데, 메신저어플에서 채팅과 파일전송기능을 혹은 미디어플레이어에서 음악듣기와
동영상보기의 기능을 수행하기도 한다. 하나의 어플에서 멀티태스킹이 가능한 이유는 바로 멀티스레드 덕분이다.

스레드란 한 가지 작업을 실행하기 위해 순차적으로 실행할 코드를 말한다. 하나의 스레드는 하나의 코드실행흐름이기에
한 프로세스 내에 스레드가 2개라면, 2개의 코드실행흐름이 생긴다는 의미이다. 멀티스레드는 하나의 프로세스 내부에 생기기에
어느 한 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어서 다른스레드에 피해를 준다. 각각의 스레드마다 예외처리를 잘 해줘야 한다.

메인스레드는 main()을 실행하면서 시작된다. 첫코드부터 순차적으로 아래로가서 마지막코드를 실행하면 메인스레드는 종료된다.
메인스레드는 필요에 따라 작업 스레드들을 만들어서 병렬로 코드를 실행할 수 있다. 이게 멀티스레드 생성을 해서 멀티태스킹을 수행하는 것이다.

메인스레드는 항상 존재하기에, 메인작업 이외에 추가적인 병렬작업의 수만큼만 스레드를 생성하면 된다.
작업스레드 생성은 이 친구역시 객체로 생성되기에 클래스가 필요하다.
java.lang.Thread 클래스를 직접 객체화해서 생성해도 되지만, Thread 클래스르 상속해서 하위클래스를 만들어 생성 할수도 있다.

Thread 클래스타입의 혹은 Thread 의 자식클래스타입의 참조변수에,
1. 생성자매개값으로 Runnable 인터페이스의 구현객체를 넣은 Thread 객체를 생성(new)해서 할당하거나
2. Thread 를 상속받은 자식클래스의 객체를 생성(new)해서 할당해서
(단, 여기서 구현객체나 자식객체모두 run()메소드를 재정의 하고있음) run()메소드를 실행할 작업스레드 객체를 생성하는것이다.(눈에 안보일뿐이다)

스레드객체를 생성하고 start()메소드를 호출하면 바로 스레드가 실행되는것이 아니라 실행대기상태(Runnable) 가 되고, 스레드 스케줄링으로 선택된
스레드가 비로소 CPU 를 점유하고 run()메소드를 실행한다. 이때는 실행상태(Running)이라 한다. run()이 모두 실행되기 전에 다시
실행대기상태로 돌아갈수있는데 그 전에 일시정지상태를 거쳐서 실행대기상태로 와야 다시 실행상태로 또 갈 수 있어서 일시정지를 거쳐야 한다.
실행대기상태로 오면 다른 스레드가 스레드스케줄링에 의해 걔만의 run()을 실행하는 실행상태로 가고, 이렇게 멀티스레드가 조금씩 run()을 실행해나감
마침내 어느 한 스레드가 run()을 끝마치면 스레드의 실행은 멈추게 되고 종료상태(Terminated)가 된다.
작업스레드는 run() 메소드 내의 코드를 실행하기 위해 존재한다.

궁금한거 한가지. 메인스레드에서 작업스레드객체를 생성후에 start()를 호출해서 작업스레드를 실행하면서 메인1 작업1 총 2개의 태스킹을 동시에 함
그러면 이거하고 메인스레드에서 어떤 객체의 메소드를 호출해서 그 코드실행흐름이 해당타입의 클래스로 가서 그 메소드가 실행되는거하고 무슨차이지?
전자는 start()가 호출되는 시점에 메인스레드는 얘대로 바로 아래코드로 넘어가서 실행하고, 작업스레드는 얘대로 run()을 실행. 서로 독립적. 동시O
후자는 객체의메소드를 호출하는 시점에 그 클래스내에 정의된 메소드로 넘어가서 반환하든 실행만하든 끝나면 다시 돌아와서 아래코드를 실행하지.
즉 메인스레드가 그 클래스로 넘어가서 실행시키고 그 메소드가 끝나면 메인스레드가 다시 원래 main()으로 돌아와서 아래코드를 실행한다. 동시X

data 라는 그릇을 채우고 빼고 채우고 빼고 정확한 교대작업

CPU(코어)에서만 run()실행가능. 이게 무슨말이냐면 많은 스레드들이 생성되서 실행대기상태에 머물러있다가 스레드스케줄링이 나 부르면
그때 코어로 들어가서 run()을 수행하다가, 주어진 시간이지나거나 우선순위가 밀리면 코어를 나와서 다른 스레드가 들어가게 물러나준다. 이런 구조!
그래서 많은 병렬작업처리가 생겨나면 그에따른 많은 스레드들이 생겨나는데 이 자체도 그렇고 CPU 도 바빠져 메모리사용량 증가. 어플의 성능저하 우려
수 백개의 크롬브라우저가 하나의 웹서버에 접속해서 무언가를 요청하는 상황이 예시. 서버다운의 우려
이를 예방하기 위한것이 스레드풀(ThreadPool)이다. 작업 처리에 사용되는 스레드를 제한된 개수만큼만 미리 생성하여
작업 큐(Queue)에 들어오는 작업들을 하나씩 미리 생성된 스레드가 맡아서 처리한다. 작업처리 다한 스레드는 그 결과를 어플로 전달하고
스레드는 다시 작업큐에서 새로운 작업을 가져와 처리하는 식이다.
 */